{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": false,
    "environment": "A",
    "integration": "SampleIntegration",
    "identifier": "Sample Integration - Simple Connector Example_6714e690-09ae-4abc-872e-84a5550f24f6",
    "connectorDefinitionName": "Sample Integration - Simple Connector Example",
    "displayName": "Sample Integration - Simple Connector Example",
    "description": "This is an example of a simple connector. It's integrated with \"api.vatcomply.com\" service and provides all of the main design ideas necessary to build a stable connector. Dynamic List defines what rates should be returned for a given currency and expects input in the format \"EUR\" etc.",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 3,
    "isAllowlistSupported": true,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Describes the name of the field where the environment name is stored. If the environment field isn't found, the environment is the default environment.",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the \"Environment Field Name\" field. Default is .* to catch all and return the value unchanged. Used to allow the user to manipulate the environment field via regex logic. If the regex pattern is null or empty, or the environment value is null, the final environment result is the default environment.",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "180",
            "description": "The timeout limit (in seconds) for the python process running current script",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Root",
            "paramValue": "https://api.vatcomply.com",
            "description": "API Root for the integration. In this case, we are integrating with \"api.vatcomply.com\" service.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Password Field",
            "paramValue": "***************",
            "description": "Example of API password field parameter. API doesn't require authentication, this parameter is just for showcase purpose.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Currencies To Fetch",
            "paramValue": "USD, EUR",
            "description": "Connector will fetch exchange rates for the provided currencies.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Create Alert Per Exchange Rate",
            "paramValue": "false",
            "description": "If enabled, connector will create a separate Alert per each exchange rate.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Severity",
            "paramValue": "Informational",
            "description": "Possible values: Critical, High, Medium, Low, Informational",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Add Attachment",
            "paramValue": "true",
            "description": "If enabled, connector will add JSON object to the alert.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Days Backwards",
            "paramValue": "30",
            "description": "Amount of days from where to fetch alerts. Max: 30.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Alerts To Fetch",
            "paramValue": "3",
            "description": "This parameter dictates how many alerts (in this case, dates) will be processed per 1 connector iteration.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Use dynamic list as blocklist",
            "paramValue": "false",
            "description": "If enabled, the dynamic list will be used as a blocklist.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Disable Overflow",
            "paramValue": "false",
            "description": "If enabled, connector will ignore the overflow mechanism.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "true",
            "description": "If enabled, verify the SSL certificate for the connection to the API Service server is valid.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy username to authenticate with.",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 1.0,
    "isScriptConnector": true,
    "script": "from __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom SiemplifyConnectorsDataModel import AlertInfo\nfrom TIPCommon.base.connector import Connector\nfrom TIPCommon.filters import filter_old_alerts\nfrom TIPCommon.smp_io import read_ids, write_ids\nfrom TIPCommon.transformation import string_to_multi_value\nfrom TIPCommon.utils import is_overflowed, is_test_run\n\nimport constants\nfrom api_client import ApiParameters, SampleApiClient\nfrom auth import AuthenticatedSession, SessionAuthenticationParameters, build_auth_params\n\nif TYPE_CHECKING:\n    import requests\n\n\nclass SimpleConnector(Connector):\n    def __init__(self, is_test_connector_run: bool) -> None:\n        super().__init__(constants.CONNECTOR_SCRIPT_NAME, is_test_connector_run)\n        self.manager: SampleApiClient | None = None\n\n    def validate_params(self) -> None:\n        \"\"\"Validate connector params with param_validator.\"\"\"\n        self.params.max_days_backwards = self.param_validator.validate_range(\n            param_name=\"Max Days Backwards\",\n            value=self.params.max_days_backwards,\n            min_limit=constants.MIN_DAYS_BACKWARDS,\n            max_limit=constants.MAX_DAYS_BACKWARDS,\n            print_value=True,\n        )\n\n        self.params.max_alerts_to_fetch = self.param_validator.validate_positive(\n            param_name=\"Max Alerts To Fetch\",\n            value=self.params.max_alerts_to_fetch,\n            print_value=True,\n        )\n\n    def init_managers(self) -> SampleApiClient:\n        \"\"\"Initialize API manager with authentication.\"\"\"\n        auth_params = build_auth_params(self.siemplify)\n        authenticator: AuthenticatedSession = AuthenticatedSession()\n        auth_params_for_session = SessionAuthenticationParameters(\n            api_root=auth_params.api_root,\n            password=auth_params.password,\n            verify_ssl=auth_params.verify_ssl,\n        )\n        authenticator.authenticate_session(auth_params_for_session)\n        authenticated_session: requests.Session = authenticator.session\n\n        api_params: ApiParameters = ApiParameters(\n            api_root=auth_params.api_root,\n        )\n\n        self.manager = SampleApiClient(\n            authenticated_session=authenticated_session,\n            configuration=api_params,\n            logger=self.logger,\n        )\n\n    def read_context_data(self) -> None:\n        \"\"\"Read context data from the SOAR platform.\"\"\"\n        self.logger.info(\"Reading already existing alerts ids...\")\n        self.context.existing_ids = read_ids(self.siemplify)\n\n    def get_last_success_time(self) -> int:\n        return super().get_last_success_time(\n            max_backwards_param_name=\"max_days_backwards\",\n            metric=\"days\",\n        )\n\n    def get_alerts(self) -> list[AlertInfo]:\n        \"\"\"Fetch alerts from the API.\"\"\"\n        alerts: list[AlertInfo] = []\n        rate = self.manager.get_connector_rates(\n            currencies=string_to_multi_value(\n                string_value=self.params.currencies_to_fetch,\n                only_unique=True,\n            ),\n            start_date=self.context.last_success_timestamp.date(),\n        )\n        for base_rate in rate.exchange_rates:\n            alerts.extend(\n                base_rate.to_alerts(\n                    create_per_rate=self.params.create_alert_per_exchange_rate,\n                    severity=self.params.alert_severity,\n                    env_common=self.env_common,\n                    attachment=self.params.add_attachment,\n                )\n            )\n\n        return alerts\n\n    def filter_alerts(self, fetched_alerts: list[AlertInfo]) -> list[AlertInfo]:\n        \"\"\"Filter out alerts that are already processed or overflowed.\"\"\"\n        return filter_old_alerts(\n            self.siemplify,\n            fetched_alerts,\n            self.context.existing_ids,\n            \"alert_id\",\n        )\n\n    def max_alerts_processed(self, processed_alerts: list[AlertInfo]) -> bool:\n        \"\"\"Check if the maximum number of alerts to process has been reached.\"\"\"\n        if len(processed_alerts) >= self.params.max_alerts_to_fetch:\n            return True\n\n        return False\n\n    def pass_filters(self, alert: AlertInfo) -> bool:\n        \"\"\"Check if the alert passes the whitelist filter.\"\"\"\n        return alert.pass_filter(\n            soar_connector=self.siemplify,\n            create_per_rate=self.params.create_alert_per_exchange_rate,\n            use_dynamic_list_as_blocklist=self.params.use_dynamic_list_as_blocklist,\n        )\n\n    def is_overflow_alert(self, alert_info: AlertInfo) -> bool:\n        \"\"\"Check if the alert is an overflow alert.\"\"\"\n        return not self.params.disable_overflow and is_overflowed(\n            self.siemplify, alert_info, self.is_test_run\n        )\n\n    def store_alert_in_cache(self, processed_alert: AlertInfo) -> None:\n        \"\"\"Store the processed alert in the context.\"\"\"\n        self.context.existing_ids.append(processed_alert.alert_id)\n\n    def create_alert_info(self, processed_alert: AlertInfo) -> AlertInfo:\n        \"\"\"Create an AlertInfo object from the processed alert.\"\"\"\n        return processed_alert\n\n    def set_last_success_time(self, alerts: list[AlertInfo]) -> None:\n        \"\"\"Set connector's last success time.\"\"\"\n        super().set_last_success_time(alerts=alerts, timestamp_key=\"start_time\")\n\n    def write_context_data(self, alerts: list[AlertInfo]) -> None:\n        \"\"\"Write connector's context data.\"\"\"\n        if not alerts:\n            return\n\n        self.logger.info(\"Saving existing ids.\")\n        write_ids(self.siemplify, self.context.existing_ids)\n\n\nif __name__ == \"__main__\":\n    is_test = is_test_run(sys.argv)\n    connector = SimpleConnector(is_test)\n    connector.start()\n",
    "documentationLink": null,
    "deviceProductField": "Product Name",
    "eventNameField": "base",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}