{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": true,
    "isRemoteConnector": false,
    "environment": "C",
    "integration": "GoogleChronicle",
    "identifier": "Google Chronicle - Chronicle Alerts Connector_489fdb25-e1ed-4dfd-aac8-d7794d2860ad",
    "connectorDefinitionName": "Google Chronicle - Chronicle Alerts Connector",
    "displayName": "Google Chronicle - Chronicle Alerts Connector",
    "description": "Pull information about Rule based alerts from Google Chronicle. Note: dynamic list is used for filtering purposes. For all of the details please visit the documentation portal.",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 3,
    "isAllowlistSupported": true,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "180",
            "description": "Timeout limit for the python process running the current script.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Describes the name of the field where the environment name is stored. If the environment field isn't found, the environment is the default environment.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the \"Environment Field Name\" field. Default is .* to catch all and return the value unchanged. Used to allow the user to manipulate the environment field via regex logic. If the regex pattern is null or empty, or the environment value is null, the final environment result is the default environment.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Root",
            "paramValue": "https://backstory.googleapis.com",
            "description": "API root of the Chronicle instance.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "User's Service Account",
            "paramValue": "***************",
            "description": "Service Account that is used for authentication. If not provided, the default Service Account of the SecOps Instance will be used to authenticate.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Workload Identity Email",
            "paramValue": "",
            "description": "The client email address of your workload identity. You can configure either this parameter or the User's Service Account parameter. To impersonate service accounts with the workload identity email address, grant the Service Account Token Creator role to your service account. If both this and User's Service Account not provided, the default Service Account of the SecOps Instance will be used to authenticate.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Hours Backwards",
            "paramValue": "1",
            "description": "Number of hours before the first connector iteration to retrieve alerts from. This parameter applies to the initial connector iteration after you enable the connector for the first time, or used as a fallback value in cases where connector's last run timestamp expires. Maximum: 167 hours.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Alerts To Fetch",
            "paramValue": "100",
            "description": "How many alerts per type to process per one connector iteration. Default: 100.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Fallback Severity",
            "paramValue": "Medium",
            "description": "Specify the fallback severity for the detection. This parameter is going to be used, if Chronicle detection doesn't include any information related to the severity. Possible values: Critical, High, Medium, Low, Info.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "true",
            "description": "If enabled, verify the SSL certificate for the connection to the Google Chronicle server is valid.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": " Proxy Username",
            "paramValue": "",
            "description": " The proxy username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": " Proxy Password",
            "paramValue": "",
            "description": " The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Disable Overflow",
            "paramValue": "false",
            "description": "If enabled, the connector will ignore the overflow mechanism.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 76.0,
    "isScriptConnector": true,
    "script": "import sys\n\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyUtils import output_handler, unix_now\nfrom TIPCommon.extraction import extract_connector_param\nfrom TIPCommon.utils import is_overflowed\n\nfrom consts import (\n    ALERT_TYPES,\n    ALERT_TYPE_NAMES,\n    FALLBACK_SEVERITY_VALUES,\n    UNIFIED_CONNECTOR_CONNECTOR_NAME,\n    UNIFIED_CONNECTOR_DEFAULT_LIMIT,\n    UNIFIED_CONNECTOR_DEFAULT_TIME_FRAME,\n    UNIFIED_CONNECTOR_MAX_TIME_FRAME,\n)\nfrom exceptions import GoogleChronicleValidationError\nfrom ExternalAlert import ExternalAlert\nfrom GoogleChronicleManagerV2 import GoogleChronicleManagerV2\nfrom IOCAlert import IOCAlert\nfrom RuleAlert import RuleAlert\nfrom utils import convert_list_to_comma_string, is_approaching_timeout\n\n\nALERT_TYPE_OBJECTS = {\n    ALERT_TYPES.get(\"rule\"): RuleAlert,\n    ALERT_TYPES.get(\"external\"): ExternalAlert,\n    ALERT_TYPES.get(\"ioc\"): IOCAlert,\n}\n\n\nconnector_starting_time = unix_now()\n\n\n@output_handler\ndef main(is_test_run):\n    siemplify = SiemplifyConnectorExecution()\n    siemplify.script_name = UNIFIED_CONNECTOR_CONNECTOR_NAME\n    processed_alerts = []\n\n    if is_test_run:\n        siemplify.LOGGER.info(\n            '***** This is an \"IDE Play Button\"\\\\\"Run Connector once\" test run ******'\n        )\n\n    siemplify.LOGGER.info(\"------------------- Main - Param Init -------------------\")\n\n    api_root = extract_connector_param(\n        siemplify, param_name=\"API Root\", is_mandatory=True, print_value=True\n    )\n    users_service_account = extract_connector_param(\n        siemplify, param_name=\"User's Service Account\", is_mandatory=False\n    )\n    workload_identity_email = extract_connector_param(\n        siemplify, param_name=\"Workload Identity Email\", print_value=False\n    )\n    verify_ssl = extract_connector_param(\n        siemplify,\n        param_name=\"Verify SSL\",\n        input_type=bool,\n        is_mandatory=True,\n        print_value=True,\n    )\n    environment_field_name = extract_connector_param(\n        siemplify, param_name=\"Environment Field Name\", print_value=True\n    )\n    environment_regex_pattern = extract_connector_param(\n        siemplify, param_name=\"Environment Regex Pattern\", print_value=True\n    )\n    script_timeout = extract_connector_param(\n        siemplify,\n        param_name=\"PythonProcessTimeout\",\n        is_mandatory=True,\n        input_type=int,\n        print_value=True,\n    )\n    hours_backwards = extract_connector_param(\n        siemplify,\n        param_name=\"Max Hours Backwards\",\n        input_type=int,\n        default_value=UNIFIED_CONNECTOR_DEFAULT_TIME_FRAME,\n        print_value=True,\n    )\n    fetch_limit = extract_connector_param(\n        siemplify,\n        param_name=\"Max Alerts To Fetch\",\n        input_type=int,\n        default_value=UNIFIED_CONNECTOR_DEFAULT_LIMIT,\n        print_value=True,\n    )\n    fallback_severity = extract_connector_param(\n        siemplify, param_name=\"Fallback Severity\", is_mandatory=True, print_value=True\n    )\n    device_product_field = extract_connector_param(\n        siemplify, param_name=\"DeviceProductField\", is_mandatory=True\n    )\n    disable_overflow = extract_connector_param(\n        siemplify,\n        param_name=\"Disable Overflow\",\n        input_type=bool,\n        default_value=False,\n        print_value=True,\n    )\n\n    alert_types = [ALERT_TYPES.get(\"rule\")]\n\n    try:\n        siemplify.LOGGER.info(\"------------------- Main - Started -------------------\")\n\n        if not all(alert_type in ALERT_TYPES.values() for alert_type in alert_types):\n            raise GoogleChronicleValidationError(\n                f'Invalid value provided for \"Alert Types\". Possible values: '\n                f\"{convert_list_to_comma_string(list(ALERT_TYPE_NAMES.values()))}\"\n            )\n\n        if fallback_severity.lower() not in FALLBACK_SEVERITY_VALUES:\n            raise GoogleChronicleValidationError(\n                f'Invalid value provided for the parameter \"Fallback Severity\": {fallback_severity}. '\n                f\"Possible values: {convert_list_to_comma_string(FALLBACK_SEVERITY_VALUES)}.\"\n            )\n\n        if fetch_limit < 0:\n            siemplify.LOGGER.info(\n                f'\"Max Alerts To Fetch\" must be non-negative. The default value '\n                f\"{UNIFIED_CONNECTOR_DEFAULT_LIMIT} will be used\"\n            )\n            fetch_limit = UNIFIED_CONNECTOR_DEFAULT_LIMIT\n\n        if hours_backwards < 0:\n            siemplify.LOGGER.info(\n                f'\"Max Hours Backwards\" must be non-negative. The default value '\n                f\"{UNIFIED_CONNECTOR_DEFAULT_TIME_FRAME} will be used\"\n            )\n            hours_backwards = UNIFIED_CONNECTOR_DEFAULT_TIME_FRAME\n\n        if hours_backwards > UNIFIED_CONNECTOR_MAX_TIME_FRAME:\n            siemplify.LOGGER.info(\n                f'\"Max Hours Backwards\" is greater than maximum allowed value. The maximum value '\n                f\"{UNIFIED_CONNECTOR_MAX_TIME_FRAME} will be used\"\n            )\n            hours_backwards = UNIFIED_CONNECTOR_MAX_TIME_FRAME\n\n        # if padding_period is not None and (padding_period < 0 or padding_period > MAX_PADDING_PERIOD):\n        #     siemplify.LOGGER.info(f\"\\\"Padding Period\\\" must be non-negative and maximum is 12 hours. The default value \"\n        #                           f\"{DEFAULT_PADDING_PERIOD} will be used\")\n        #     padding_period = DEFAULT_PADDING_PERIOD\n\n        manager = GoogleChronicleManagerV2.create_manager_instance(\n            user_service_account=users_service_account,\n            workload_identity_email=workload_identity_email,\n            chronicle_soar=siemplify,\n            api_root=api_root,\n            verify_ssl=verify_ssl,\n        )\n\n        for alert_type in alert_types:\n            siemplify.LOGGER.info(\n                f\"Started processing {ALERT_TYPE_NAMES.get(alert_type)} alert type\"\n            )\n\n            if is_approaching_timeout(script_timeout, connector_starting_time):\n                siemplify.LOGGER.info(\n                    \"Timeout is approaching. Connector will gracefully exit\"\n                )\n                break\n\n            alert_type_processed_alerts = []\n            fetched_alerts = []\n            alert_object = ALERT_TYPE_OBJECTS.get(alert_type)(\n                siemplify, manager, script_timeout, connector_starting_time\n            )\n\n            # Read already existing alerts ids\n            existing_ids = alert_object.read_ids()\n\n            # Fetch alerts\n            filtered_alerts = alert_object.get_alerts(\n                existing_ids=existing_ids,\n                fetch_limit=fetch_limit,\n                hours_backwards=hours_backwards,\n                fallback_severity=fallback_severity,\n            )\n\n            for alert in filtered_alerts:\n                try:\n                    if is_approaching_timeout(script_timeout, connector_starting_time):\n                        siemplify.LOGGER.info(\n                            \"Timeout is approaching. Connector will gracefully exit\"\n                        )\n                        break\n\n                    siemplify.LOGGER.info(\n                        f\"Started processing {ALERT_TYPE_NAMES.get(alert_type)} alert {alert.id}\"\n                    )\n                    if is_test_run and alert_type_processed_alerts:\n                        siemplify.LOGGER.info(\n                            \"This is a TEST run. \"\n                            f\"Only 1 {ALERT_TYPE_NAMES.get(alert_type)} alert will be \"\n                            \"processed.\"\n                        )\n                        alert_type_processed_alerts = alert_type_processed_alerts[:1]\n                        break\n                    existing_ids.append(alert.id)\n                    fetched_alerts.append(alert)\n\n                    if not alert_object.pass_filters(alert):\n                        continue\n\n                    alert_info = alert_object.get_alert_info(\n                        alert,\n                        GetEnvironmentCommonFactory().create_environment_manager(\n                            siemplify,\n                            environment_field_name,\n                            environment_regex_pattern,\n                        ),\n                        device_product_field,\n                    )\n\n                    if not disable_overflow:\n                        if is_overflowed(siemplify, alert_info, is_test_run):\n                            siemplify.LOGGER.info(\n                                f\"{str(alert_info.rule_generator)}\"\n                                f\"-{str(alert_info.ticket_id)}\"\n                                f\"-{str(alert_info.environment)}\"\n                                f\"-{str(alert_info.device_product)} \"\n                                \"found as overflow alert. Skipping...\"\n                            )\n                            # If is overflowed we should skip\n                            continue\n\n                    alert_type_processed_alerts.append(alert_info)\n                    siemplify.LOGGER.info(\n                        f\"{ALERT_TYPE_NAMES.get(alert_type)} alert {alert.id} was created.\"\n                    )\n\n                except Exception as e:\n                    siemplify.LOGGER.error(\n                        f\"Failed to process {ALERT_TYPE_NAMES.get(alert_type)} alert {alert.id}\"\n                    )\n                    siemplify.LOGGER.exception(e)\n\n                    if is_test_run:\n                        raise\n\n                siemplify.LOGGER.info(\n                    f\"Finished processing {ALERT_TYPE_NAMES.get(alert_type)} alert {alert.id}\"\n                )\n\n            else:\n                if not is_test_run:\n                    siemplify.LOGGER.info(\n                        f\"Saving {ALERT_TYPE_NAMES.get(alert_type)} timestamp.\"\n                    )\n                    alert_object.save_timestamp(fetched_alerts)\n\n            if not is_test_run:\n                siemplify.LOGGER.info(\n                    f\"Saving {ALERT_TYPE_NAMES.get(alert_type)} existing ids.\"\n                )\n                alert_object.write_ids(list(set(existing_ids)))\n\n            processed_alerts.extend(alert_type_processed_alerts)\n            siemplify.LOGGER.info(\n                f\"Processed {len(alert_type_processed_alerts)} \"\n                f\"{ALERT_TYPE_NAMES.get(alert_type)} alerts\"\n            )\n\n    except Exception as e:\n        siemplify.LOGGER.error(f\"Got exception on main handler. Error: {e}\")\n        siemplify.LOGGER.exception(e)\n\n        if is_test_run:\n            raise\n\n    siemplify.LOGGER.info(f\"Created total of {len(processed_alerts)} cases\")\n    siemplify.LOGGER.info(\"------------------- Main - Finished -------------------\")\n    siemplify.return_package(processed_alerts)\n\n\nif __name__ == \"__main__\":\n    # Connectors are run in iterations. The interval is configurable from the ConnectorsScreen UI.\n    is_test = not (len(sys.argv) < 2 or sys.argv[1] == \"True\")\n    main(is_test)\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/google-chronicle#chronicle-alerts-connector",
    "deviceProductField": "alert_type",
    "eventNameField": "event_type",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}